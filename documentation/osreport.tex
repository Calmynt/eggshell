\documentclass[12pt, a4paper]{report}
\usepackage{personalstyle}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\begin{document}
    \begin{titlepage}
        \centering
        \Huge{Eggshell}\\
        \Large{an Operating Systems project}\\
        \normalsize{CPS1012}\\[10pt]
        \Large{Andre' Jenkins}\\
        \small{76999M}
    \end{titlepage}

    \tableofcontents

    \clearpage

    \chapter{Structure of the code}
        The code was structured into different directories, so that they may
        be organised according to what they are supposed to achieve.
        \section{Main files}
            The files here are ones which are used in the front layer of the
            eggshell. Here you may find a main C file that uses the eggshell
            functions, the main eggshell \texttt{.c / .h} files which either
            call multiple other functions, or are simple enough to be on the
            front layer, and other files such as the Makefile, any scripts,
            testfiles, and other miscellaneous files.

            \begin{description}
                \item[\textbf{main.c} --- ]
                    The main \texttt{C} file that the executable is retrieved
                    from. Uses libraries such as \texttt{eggshell} and 
                    \texttt{linenoise}.
                \item[\textbf{eggshell.c/h} ---]
                    The \texttt{eggshell library} used by the main file in order
                    to start the eggshell and utilise it. Uses multiple libraries
                    that are all found in the \texttt{src} directory.
                \item[\textbf{Makefile/Makefile-GCC} ---]
                    The Makefile necessary to generate the executable. The current
                    default Makefile uses the \texttt{Clang} compiler, for reasons
                    stated in the \texttt{README.md} file. To use the Makefile that
                    utilises the \texttt{GCC} compiler instead, either change the
                    name of the \texttt{Makefile-GCC} file, or run \texttt{switch.sh}
                \item[\textbf{switch.sh} ---]
                    A script that aids in switching compilers for the makefile.
                    This was written for each switching between \texttt{Clang} and
                    \texttt{GCC}, due to the ease of debugging with \texttt{Clang},
                    and the standard nature of the \texttt{GCC} compiler.
                \item[\textbf{README.md} ---]
                    The \texttt{README} file holds the instructions to compiling the
                    program, as well as a quick summary of the program and its utilities.
                \item[\textbf{testinput.txt} ---]
                    A file used to test the capabilities of the eggshell. 
                    Running \texttt{./eggshell test} will immediately launch
                    the eggshell and run this script, to provide a quick 
                    testing method.
                \item[\textbf{LICENSE, .gitignore \& .yml files} ---]
                    Files that are unimportant to the project itself.
                    These were used for \texttt{git} purposes, as the project 
                    was also uploaded as a \texttt{git} repository.
            \end{description}

        \section{Source files}
            The files found here are the bulk of the code making up the 
            eggshell. In here, every single \texttt{eggshell header library}
            is present, all of them with their own specific and complicated purpose.
            These were seperated from the main \texttt{eggshell} file 
            in order to organise the core of the project from the 
            specific elements making up the project itself.

            \begin{description}
                \item[\bf{variables.c/h} ---]
                    Contains all the functions and structs relating to the
                    variables created and stored by the \tx{eggshell}. 
                    For example, all the \bb{shell} variables can be found
                    here.
                \item[\bf{printer.c/h} ---]
                    The main file dealing with the \tx{print} command.
                \item[\bf{proc\_manager.c/h} ---]
                    The file dealing with the execution of external commands.
                \item[\bf{sig\_handler.c/h} ---]
                    Contains the \tx{signal handler} function used in order 
                    to suspend and interrupt processes. Also contains an 
                    additional function in order to reawaken a suspended
                    process.
                \item[\bf{redirection.c/h} ---]
                    The main file dealing with \tx{input/output} redirection.
                \item[\bf{pipe\_manager.c/h} ---]
                    Contains functions dealing with the piping system that the
                    \tx{eggshell} offers. Also contains a special execution function,
                    rather than using the one found in \tx{proc\_manager.c/h}
            \end{description}
        
        \section{Other files}
            There are also other directories that contain files that aren't
            integral to the functionality of the eggshell, but are still related
            somewhat.

            \begin{description}
                \item[\bf{documentation/} ---]
                    Contains the \tx{.tex} file that generated this report,
                    as well as other items related to it. In order to recompile it,
                    you'd most likely need to install \TeX{}live first.
                \item[\bf{ci/} ---]
                    Unrelated to the main project. The Makefile here is used for 
                    Continuous Integration for the \tx{git} repository.
                \item[\bf{add-on/} ---]
                    Contains the \tx{linenoise.c/h} library that was used in the 
                    main file to simulate a terminal's prompt with input.
                \item[\bf{.vscode/} ---]
                    Contains files that helped with debugging/building the project
                    in \tx{Visual Studio Code}.
            \end{description}

    \clearpage

    \chapter{Code documentation}
        \section{\tx{main.c}}
            \subsection{Use of \tx{main.c}}
                This code is mainly used in order to produce an executable
                using the \tx{eggshell.} This is because the eggshell is
                mainly used as a sort of \tx{API,} which interfaces with
                the inner functions that the eggshell offers.

                As a result, the \tx{main} implements some not-so-integral
                elements of the eggshell, such as an introduction/boot-up
                screen, an additional \tx{test} argument feature, and some
                \tx{linenoise} functions such as history \ii{(ability to
                use $\uparrow$ and $\downarrow$ keys to traverse through
                older commands)}. It also uses the function \tx{updatePrompt();}
                which updates the prompt of the eggshell in order to display
                the current directory.

                A thing to note is that the external command \tx{clear} is run by the line:

                \texttt{runLine(\quot clear\quot, \quot\quot);}

                ...which is an external function found in \tx{eggshell.c}.

                \bb{\myul{Note:}} In order to test the first part of the program,
                which loads \tx{testinput.txt} and runs it, you'd need to run
                the eggshell with the \tx{test} parameter: \tx{./eggshell test}

                \clearpage


        \clearpage

        \section{\tx{eggshell.c}}
            \subsection{Use of \tx{eggshell.c}}
                This file serves as the \bb{core} of the eggshell itself.
                Its main method, \tx{execute}, executes the line inputted
                by the user. Almost every other function of the eggshell is
                accessed through this main file automatically, using parsing.

            \mysubsect{\tx{void initEggshell}}{\tx{()}}
                All this function does is initialise the eggshell. To initialise,
                all it needs to do is initialise its shell variables, which is 
                does by calling the method \tx{initShellVars()} from
                \tx{variables.c}

            \mysubsect{\tx{void runLine}}{\tx{(char *command, char *line)}}
                This function executes the command \tx{command} with the
                arguments found in \tx{line}. An example of this is:

                \tx{command} = \tx{\quot chdir\quot} and \tx{line} = \tx{\quot ../src/\quot}

                Which would execute \tx{chdir} with arguments \tx{../src/}. It does this
                by having a significant if/else-if block that checks which function to execute:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \begin{minted}[gobble=20, breaklines, frame=single, linenos=true]{C}
                    if(strcmp(command, "print") == 0) printLine(line);
                    else if(strcmp(command, "all") == 0) showShellVars();
                    else if(strcmp(command, "vars") == 0) displayUserVars();
                    else if(strcmp(command, "chdir") == 0) changeDirectory(line); 
                    else if(strcmp(command, "source") == 0) runScript(line);
                    else if(strcmp(command, "fg") == 0) resumeProcessSignal(FOREGROUND);
                    else if(strcmp(command, "bg") == 0) resumeProcessSignal(BACKGROUND);
                    else externalCommand(command, line);
                \end{minted}
                \endgroup

                The signal handler is also initialised by calling the \tx{init\_handler()}
                function in \tx{sig\_handler.c}.

                \clearpage
            
            \mysubsect{\tx{void changeDirectory}}{\tx{(char* directory)}}
                This function changes the directory to the directory specified by
                the parameter. This is done using the inbuilt \tx{chdir} function.

                If changing the directory was successful, the \tx{\$CWD} shell
                variable is updated, and the new directory is displayed.

                However, if it was failing, \tx{perror} is used to display the
                error message.
            
            \mysubsect{\tx{void runScript}}{\tx{{(char *filename)}}}
                All this function does, is load a \tx{script} file which can have
                any extension, and execute its commands line by line. It contains
                measures, such as ignoring any line starting with \tx{\#}, or 
                any empty lines. This effectively enables commenting support for 
                scripts using the \tx{\#} symbol.

                It also emulates a prompt, so that the output generated when running 
                the script could be more readable to the user.

                \clearpage
            
            \mysubsect{\tx{void execute}}{\tx{(char *line)}}
                This function is the main one to be executed.
                It is what reveals the eggshell functions to the user,
                as all other functions are accessed via this one.

                What it does first of all, is check the line's structure
                in order to parse it for specific cases. For example, in 
                this section here:
                
                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=27, lastline=32]{../eggshell.c}
                \endgroup
                The first line checks whether the line is identical to the
                exit command \tx{exit}, at which point the \tx{clear} command
                is run, and the program stops executing. Line 30 and 32, use
                functions from \tx{variables.c} and \tx{pipe\_manager.c} respecively,
                to check whether the line assigns a variable, or contains pipes in it.
                An exitcode of 0 from these functions means that they were detected.

                If none of these are detected, the function then attempts to check
                whether the line contains any redirection symbols such as \tx{>},
                \tx{>>}, \tx{<} or \tx{<<<}:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=37, lastline=43]{../eggshell.c}
                \endgroup
                The results of the \tx{strstr} function used are stored in variables.
                These variables have two uses: They are used as flags to check which
                redirection symbol was found, \bb{and} they point to the first character
                of the symbol itself, which is useful. The flag variables \tx{out} and
                \tx{in}, also serve a purpose which will be gone into later on.

                \clearpage

                After this, a conditional \tx{if-else} block is used to parse the line
                for redirection. Depending on which \tx{char*} flags where set, the
                respective function from \tx{redirection.c} is called:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=45, lastline=53]{../eggshell.c}
                \endgroup
                One can also note, that one of the integer flag variables \tx{in/out} is
                also set to 1. This is used to call the appropriate redirection function
                later on.

                After doing so, two lines are used. One uses the \tx{strsep} function to
                seperate the command from the arguments, and the other calls the 
                redirect initialisation function from \tx{redirection.c}

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=55, lastline=58]{../eggshell.c}
                \endgroup
                After this, the actual execution of the function is done. Depending on 
                the integer flags triggered, the appropriate block of code in the
                conditional loop is run. One begins redirecting the input, one redirects
                the output, and in the case that neither of these flags are set, the
                line is simply executed.

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=60, lastline=72]{../eggshell.c}
                \endgroup

        \section{\tx{printer.c}}
            \subsection{Use of \tx{printer.c}}
                This file handles the \tx{print} command. It's main purpose
                is to print the line, being able to detect whether a part of
                the string is escaped in quotation marks, and replacing 
                unescaped variable references with their value.

            \mysubsect{\tx{void printLine}}{\tx{(char *line)}}
                The main function of the file, it is the primary function to
                be called from \tx{printer.c}. It achieves the aforementioned
                goal by splitting the line accordingly, and passing the 
                segments of the split line to the other function in the same file.

                The splitting is done using \tx{strsep}, and an integer variable
                \tx{escaped} was used to determine whether the segment was escaped.

                For example, a line such as:

                \begin{center}
                    hello \$USER, and wel\quot come to the \$HOME\quot
                \end{center}
                
                Will be split into several pieces like:

                \begin{center}
                    hello --- \$USER, --- and --- wel --- come --- to --- the --- \$HOME
                \end{center}

                ...and the segments are then sequentially handed off to the other function.
                Note that after the \tx{wel} segment, the \tx{escaped} variable is flipped.

                \clearpage
            
            \mysubsect{\tx{void printSeg}}{\tx{(char *segment, int escaped)}}
                This function utilises its parameters to print the segment,
                replacing the segment [or a part of it] with a value if it
                is found to be a variable name.

                If the \tx{escape} variable is set to 1, then the segment is
                simply printed without considering the rest of the function.
                However, if it isn't, then the following steps are covered:

                \begin{itemize}
                    \item \bb{IF} the first character is '\$', start reading what's after it.
                        \begin{itemize}
                            \item \bb{IF} the string contains any invalid variable characters
                                \ii{(any character that isn't a capital english letter)},
                                terminate reading, and consider what has been read to be
                                the variable name.
                            \item Retrieve the value of the variable with the name that
                                was read.
                            \item \bb{IF} the variable exists, and the reading was stopped,
                                print the value, followed by the rest of the segment.
                            \item \bb{ELSE IF} the variable exists, and no invalid characters were
                                found, print the value.
                            \item \bb{ELSE}, print the segment.
                        \end{itemize}
                    \item \bb{ELSE}, print the segment.
                \end{itemize}

                For example in the line above, \$USER would be replaced by the value,
                whereas \$HOME would be printed as it is, as it was escaped.

                A limitation of this is that if a segment contains \$ anywhere that isn't
                its first character, it is ignored. For example, if \$A is B, \tx{\$Aees}
                would be printed as \tx{Bees}, whereas \tx{a\$Ae Lincoln} would remain
                the same, instead of being printed as \tx{aBe Lincoln}.

                \clearpage
            
        \section{\tx{sig\_handler.c}}
            \subsection{Use of \tx{sig\_handler.c}}
                This file contains functions relating to any signals, or any effects
                resulting from signals. To be more precise, it contains a \ii{signal handler},
                and a way to wake up a suspended process.

                This was split into a seperate file for sake of organization, as having it
                bundled with the \tx{eggshell.c} file would have added more complexity
                to the already significant file.

            \mysubsect{\tx{void signal\_handler}}{\tx{(int signo)}}
                This is the signal handler that is initialised by \tx{sigaction}.
                
                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=11, lastline=25]{../src/sig_handler.c}
                \endgroup\\[-30pt]
                It is lacking in \tx{printf} statements, as after some research,
                it was found that it is not \tx{re-entrant}, or \tx{async-signal-safe},
                meaning that if, for example, in the middle of running \tx{printf}
                in a signal handler, another signal is caught, the program might 
                end up in a deadlock.

                A \tx{SIGINT} signal is handled by simply sending the signal to the
                current process, whereas a \tx{SIGTSTP} is handled by sending the
                signal, then setting the \tx{resuspended} flag to 1, after which the
                pid of the now suspended process is appended to an array of pid's
                using a variable that keeps count of how many suspended processes there are.
                This ensures that multiple processes can be suspended and restored normally.

                \clearpage
            \mysubsect{\tx{void resumeProcessSignal}}{\tx{{(int state)}}}
                This function activates in the case of either the \tx{fg} or
                \tx{bg} commands. It's purpose is to resume a suspended process
                by calling a function from \tx{proc\_manager.c}. This is done 
                in order to abstract the process managing \ii{(with \tx{waitpid}
                etc...)} from the signal handler, while at the same time allowing
                access to the pid of the suspended process.

                The correct pid is handed off to the function by using the 
                \tx{last\_suspended} variable. This makes process suspension seem
                like a stack, \bb{last suspended, first resumed}. If the suspension
                succeeds, the \tx{last\_suspended} variable is decremented, and the
                exitcode is set to 0. However, if for some reason it does not succeed,
                there are two cases: \ii{the process is unresponsive} or \ii{the process
                was resuspended.} In this case, the exit code is set to reflect which
                outcome happened, \tx{-1} being an error and \tx{18} being an indication
                of another suspension \ii{(18 is the SIGNO of SIGTSTP)}.
            
            \mysubsect{\tx{void init\_handler}}{\tx{()}}
                All this function does is initialise the signal handlers that are to be
                used. It does this by use of \tx{sigaction} rather than \tx{signal},
                for multiple reasons:
                    \begin{itemize}
                        \item \tx{signal} performs differently on different systems,
                            making it an unpredictable function to use.
                        \item \tx{signal} automatically resets the signal action back
                            to \tx{SIG\_DFL} after use. This means that during the time
                            in which the signal is triggered and the handler is 
                            reinitialized, \ii{the system is vulnerable to additional signals,
                            which would not be handled}.
                        \item \tx{sigaction} permits the blocking of signals, which if needed
                            in the future, would be impossible to implement with \tx{signal}
                    \end{itemize}
                
                    Other than the initialisation of the \tx{sigaction} struct, the
                    handler is initialised to deal with \tx{SIGINT} and \tx{SIGTSTP}
                    signals accordingly.

        \section{\tx{redirection.c}}
            \subsection{Use of \tx{redirection.c}}
                The purpose of this file is to handle all \bb{input} and
                \bb{output} redirection. It parses a line for any redirection
                symbols, initialises the redirection using a filename
                \ii{unless \tx{<<<} is detected}, and also starts the redirection,
                depending on its own flags and how they were set.
                
            \subsection{Parsing functions}
                The functions \tx{out\_redirect\_parse} and \tx{in\_redirect\_parse}
                both have very similar code that functions differently in other
                to be more specialised while also simplifying the code from having
                too many conditional blocks.

                Both of them require three strings, \bb{two} specifying pointers
                to the symbols, and \bb{one} which contains the line itself.

                These are passed in the parameter in order for the functions to know
                which action is supposed to happen, and how the line is meant to be
                parsed. This is because, in the case of \tx{<} and \tx{>}, one can 
                simply split according to those symbols and be left with the two
                elements required, albeit with additional whitespace, whereas in the
                case of \tx{<<<} and \tx{>>}, one would need to perform some 
                pointer arithmetic to split the strings accordingly.

                Let's take the \tx{in\_redirect\_parse} function as an example:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=42, lastline=51]{../src/redirection.c}
                \endgroup
                Here, \tx{in\_string} and \tx{in\_file} serve as both pointers to
                the symbol, and flags as to which symbol is present, with
                \tx{in\_string} pointing to \tx{<<<} and \tx{in\_file} pointing to
                \tx{<}. If the former was detected, \tx{filename} is set to a pointer
                \ii{three characters away} from the symbol, whereas if the latter
                was detected instead, \tx{filename} is set to a pointer
                \ii{one character away}. In both cases, the respective flag is also set.

                This ends up setting the filename to whatever is after the symbol, as
                whichever symbol was pushed, the pointer was moved away from it anyways.

                However, this leaves two problems - the left part of the line still
                hasn't been parsed yet, and the start of the filename may still
                contain whitespace.

                These are both solved by the upcoming \tx{strsep} and pointer arithmetic.
                The \tx{line} string, which still points to the whole thing, is split
                according to the \tx{<} delimiter \ii{(\tx{>} for output)}, causing the
                \tx{line} string to now contain only the command. As for the filename,
                it is placed in a loop, where if its first character is a space, its
                pointer is incremented by one. This means that it does not matter how
                many whitespaces are behind the filename, they will all be removed by the
                loop. As for the command, any whitespace at the end will not interfere,
                as the \tx{execution} function in \tx{proc\_manager.c} will ignore those.

            \mysubsect{\tx{int init\_redirect}}{\tx{(char *filename)}}
                All this function does is open the correct file descriptor,
                depending on which flags were set. This is done using an
                integer variable \tx{filefd}, which would hold the descriptor,
                and the \tx{open} function. The differences between \tx{>}
                and \tx{>>>} is simply whether the \tx{O\_TRUNC} macro or the 
                \tx{O\_APPEND} macro is used, and for \tx{<}, it's as simple as
                using \tx{O\_RDONLY}.

                However for \tx{<<<}, the \tx{filename} string would contain an 
                actual string, rather than a filename. As a result, a temporary
                file \tx{stdin.tmp} is created in order to store the string in,
                and the temporary file is then subsequently opened. This has the
                benefit of having the redirection be the same for both \tx{<<<}
                and \tx{<}, abstracting it from the actual redirection function.
                \clearpage
            \subsection{Redirection functions}
                These are grouped together for the same reason the parsing
                functions are. The code is similar, however to avoid 
                unnecessary long conditionals, they were split into two.

                In this case, we'll take the example for the output redirection:
                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=86, lastline=98]{../src/redirection.c}
                \endgroup
                The first \tx{dup} call is used in order to duplicate the file
                descriptor of \tx{stdout} to \tx{save\_out}. This is needed later
                in order to restore \tx{stdout}.

                Then, the \tx{dup2} in the if-condition sets our readymade 
                file descriptor, which was set in the \tx{init\_redirect} function,
                as the replacement for \tx{stdout}. If this fails, the redirection
                aborts, and the error code is reported, as well as the exitcode 
                being set accordingly.

                However if it succeeds, 0 is returned, showing that the redirection
                occured successfully. 

                This differs from \tx{stdin} in that a different variable is used 
                to store the file descriptor for \tx{stdin}, and \tx{stdin} is 
                replaced instead of \tx{stdout}.

                \clearpage

            \mysubsect{\tx{void close\_redirects}}{\tx{(int direction, int filefd)}}
                What this function does is reset all of the redirection that
                was initialised and used so far. It does this by flushing
                \tx{stdout} or \tx{stdin}, depending on which kind of redirection
                occured, and then closing the file descriptor \tx{filefd}.

                Our saved file descriptor, \tx{save\_in/save\_out}, then replaces
                the place our old, now closed file descriptor occupied, after which
                that is closed as well.

                Depending on whether the temporary file was created, it is then
                removed, as we have no more use for it.

                After doing so, to ensure that everything is reset, every single
                flag variable within the file is set to 0, including the
                \tx{save\_out/save\_in} descriptors. This is so that the next time
                redirection happens, it would be as if a redirection never happened
                at all.

                \clearpage

        \section{\tx{proc\_manager.c}}
            \subsection{Use of \tx{proc\_manager.c}}
                The use of this file is to manage everything doing
                with processes. This includes a \tx{fork-exec} pattern
                for external commands and handling the resumption of
                suspended processes.
            
            \mysubsect{\tx{char** pathsToCommArr}}{\tx{(int *pathn, char *program)}}
                This function is meant to be a \ii{helper} to the main 
                function of the file, as it produces an array of possible
                \tx{PATH}s that show where the product is.

                Firstly, the \tx{PATH} variable is retrieved, and copied
                into a seperate string, so that any modifications to the
                new string do not reflect back to our shell variable.
                Then, the array of paths is created and initialised.

                After doing so, we have the following code:

                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=97, lastline=114]{../src/proc_manager.c}
                \endgroup

                The delimiter's purpose is to store what we will be splitting
                the paths by --- the colon. \tx{pathnL} will also be the
                temporary variable in which we'll store the amount of paths.

                Inside the loop, \tx{path} will store the freshly seperated
                path from the \tx{paths} string, at which point it is stored
                in the \tx{patharr} array. Said path then has \tx{/<program name>}
                appended to it, as that would be the possible full path of the 
                program.

                After doing so, the path array is reallocated some additional
                memory in advance, so that it would be able to store an additional
                path. 

                Once the loop breaks, the parameter \tx{*pathn} is set to
                \tx{pathnL}. This is so that the length of the paths can be used
                outside this function. After doing so, the array of paths is then
                returned.

            \mysubsect{\tx{void externalCommand}}{\tx{(char *command, char *varargs)}}
                This function executes a command that does not belong to the
                \tx{eggshell} using \tx{fork-exec}. The parameters are the name 
                of the command itself, and a single string containing all the 
                arguments of the command. A command with no arguments will have 
                an empty string as \tx{varargs}.

                The function first initialises all the variables it will need:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=14, lastline=28]{../src/proc_manager.c}
                \endgroup\\

                Here's a small description for each of these variables:
                
                \begin{description}
                    \item[\tx{args} --- ] 
                        Where the array of arguments will be stored.
                    \item[\tx{arg} --- ]
                        Temporary variable used to store the argument to be 
                        added to \tx{args}
                    \item[\tx{argc} --- ]
                        The number of arguments present.
                    \item[\tx{arg\_delimiter[2]} --- ]
                        Used to split the \tx{varargs} string into individual
                        arguments
                    \item[\tx{BG} --- ]
                        Flag whose purpose is to signal whether the process should
                        be run in the background or foreground. 0 means foreground.
                    \item[\tx{envp} --- ]
                        Contains all environment variables, the ones belonging to
                        the main shell, \bb{and} \tx{eggshell} variables.
                    \item[\tx{pid} --- ]
                        Stores the process id of the forked process.
                    \item[\tx{pathn} --- ]
                        Contains the amount of paths that are present in \tx{paths}
                    \item[\tx{paths} --- ]
                        The array of paths to cycle through when executing a command. 
                \end{description}

                The following loop then splits \tx{varargs} into \tx{args}
                using the \tx{arg\_delimiter}, after which the main 
                conditional block is encountered.

                Here, there are three possibilities. We are in the child,
                we are in the parent, or the forking failed. First, we will
                consider the child.

                For the child, it is pretty simple. The first argument in
                \tx{args} is set to the current \tx{path} we are attempting
                to access, and the numerous paths are cycled through until 
                the program is found and then executed, or all the paths are
                exhausted and an error message is returned.

                For the parent, it is slightly more complicated.
                First, the \tx{current\_pid} global variable is set to the pid
                of the process to be used by the signal handler, and then the 
                \tx{pgid} of the forked process is set to itself. This means that
                if a signal is recieved, the signal sent by the signal handler
                will only affect the current process running in the \tx{foreground}.
                If this line was omitted, all children would receive the same signal,
                even ones who are suspended or in the background.

                After doing so, an if block will execute if \tx{\&} was not detected
                at the end of \tx{varargs}. If it was, the function will ignore this
                block, hence letting the process run in the background. However if it
                wasn't, the parent will wait for the process to finish:

                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=67, lastline=77]{../src/proc_manager.c}
                \endgroup

                The \tx{status} variable stores the status code of how the process
                terminated. The \tx{WIFEXITED} and \tx{WIFSIGNALED} macros check
                whether the process terminated normally or with a signal. Then, 
                \tx{WEXITSTATUS(status)} or \tx{WTERMSIG(status)} will show us 
                the exitcode of the process, or the signal that stopped the process
                respectively.

                \tx{WUNTRACED} was used in \tx{waitpid} as it waits for the process
                to finish, however if the process is suspended, it will immediately
                stop waiting and continue on. After this point, the function will then
                return.

                If, however, the forking failed, \tx{perror} is used to showcase why
                that is the case.

                \clearpage

            \mysubsect{\tx{int resumeProcess}}{\tx{(int state, pid\_t process)}}
                The purpose of this function is to resume a previously suspended 
                process. This is done by using the \tx{pid\_t} given in the parameter,
                and checking whether the program should be resumed in the foreground
                or background using the \tx{state} variable.

                Firstly, the \tx{resuspended} variable is reset to 0, after which a
                \tx{SIGCONT} signal is sent to the suspended process. If this failed,
                \tx{perror} is used to show why, and an error code of 1 is returned.

                If it doesn't fail, the \tx{current\_pid} is then set to the now
                recovered process. The same waiting conditional block that was in
                \tx{externalCommand} is placed here, depending on whether 
                \tx{state} was set to the macro \tx{FOREGROUND} or \tx{BACKGROUND}.

                There is an extra step however. \tx{resuspended} is checked again,
                to know whether the resumed process was suspended again. If it is
                still set to 0, then an exitcode of 0 is returned, showing everything
                executed normally. However, if it is now set to 1, an exitcode of 
                18 is returned, showing that the process was suspended again.
                This number was chosen because it is the signal number of \tx{SIGTSTP}.

                \bb{\myul{Note:}} The \tx{currentPid} function is omitted from the
                documentation as its function is obvious, and it only contains one
                line of code as a result. Its only purpose is to make a variable
                accessible by other files.

                \clearpage
                
        \section{\tx{variables.c}}
            \subsection{Use of \tx{variables.c}}
                This file handles everything to do with variables.
                This includes assignment, modification, retrieval,
                and manipulation. It also helps initialise the
                \tx{eggshell} by setting the shell variables.
                It is one of the most used files in the system, as
                multiple other functions require the use of variables,
                whether it be as a \tx{struct} or just their values.

            \mysubsect{\tx{int parse\_var}}{\tx{(char *line)}}
                This function detects whether the line passed is
                attempting to assign a variable, or modify its value.
                It also validates the line, and stops further execution
                of the line if it detects an invalid assignment.
\end{document}