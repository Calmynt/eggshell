\documentclass[12pt, a4paper]{report}
\usepackage{personalstyle}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\begin{document}
    \begin{titlepage}
        \centering
        \Huge{Eggshell}\\
        \Large{an Operating Systems project}\\
        \normalsize{CPS1012}\\[10pt]
        \Large{Andre' Jenkins}\\
        \small{76999M}
    \end{titlepage}

    \lstset{
        frame       = single,
        numbers     = left,
        showspaces  = false,
        showstringspaces    = false,
        captionpos  = t,
        caption     = \lstname
    }

    \tableofcontents

    \clearpage

    \chapter{Structure of the code}
        The code was structured into different directories, so that they may
        be organised according to what they are supposed to achieve.
        \section{Main files}
            The files here are ones which are used in the front layer of the
            eggshell. Here you may find a main C file that uses the eggshell
            functions, the main eggshell \texttt{.c / .h} files which either
            call multiple other functions, or are simple enough to be on the
            front layer, and other files such as the Makefile, any scripts,
            testfiles, and other miscellaneous files.

            \begin{description}
                \item[\textbf{main.c} --- ]
                    The main \texttt{C} file that the executable is retrieved
                    from. Uses libraries such as \texttt{eggshell} and 
                    \texttt{linenoise}.
                \item[\textbf{eggshell.c/h} ---]
                    The \texttt{eggshell library} used by the main file in order
                    to start the eggshell and utilise it. Uses multiple libraries
                    that are all found in the \texttt{src} directory.
                \item[\textbf{Makefile/Makefile-GCC} ---]
                    The Makefile necessary to generate the executable. The current
                    default Makefile uses the \texttt{Clang} compiler, for reasons
                    stated in the \texttt{README.md} file. To use the Makefile that
                    utilises the \texttt{GCC} compiler instead, either change the
                    name of the \texttt{Makefile-GCC} file, or run \texttt{switch.sh}
                \item[\textbf{switch.sh} ---]
                    A script that aids in switching compilers for the makefile.
                    This was written for each switching between \texttt{Clang} and
                    \texttt{GCC}, due to the ease of debugging with \texttt{Clang},
                    and the standard nature of the \texttt{GCC} compiler.
                \item[\textbf{README.md} ---]
                    The \texttt{README} file holds the instructions to compiling the
                    program, as well as a quick summary of the program and its utilities.
                \item[\textbf{testinput.txt} ---]
                    A file used to test the capabilities of the eggshell. 
                    Running \texttt{./eggshell test} will immediately launch
                    the eggshell and run this script, to provide a quick 
                    testing method.
                \item[\textbf{LICENSE, .gitignore \& .yml files} ---]
                    Files that are unimportant to the project itself.
                    These were used for \texttt{git} purposes, as the project 
                    was also uploaded as a \texttt{git} repository.
            \end{description}

        \section{Source files}
            The files found here are the bulk of the code making up the 
            eggshell. In here, every single \texttt{eggshell header library}
            is present, all of them with their own specific and complicated purpose.
            These were seperated from the main \texttt{eggshell} file 
            in order to organise the core of the project from the 
            specific elements making up the project itself.

            \begin{description}
                \item[\bf{variables.c/h} ---]
                    Contains all the functions and structs relating to the
                    variables created and stored by the \tx{eggshell}. 
                    For example, all the \bb{shell} variables can be found
                    here.
                \item[\bf{printer.c/h} ---]
                    The main file dealing with the \tx{print} command.
                \item[\bf{proc\_manager.c/h} ---]
                    The file dealing with the execution of external commands.
                \item[\bf{sig\_handler.c/h} ---]
                    Contains the \tx{signal handler} function used in order 
                    to suspend and interrupt processes. Also contains an 
                    additional function in order to reawaken a suspended
                    process.
                \item[\bf{redirection.c/h} ---]
                    The main file dealing with \tx{input/output} redirection.
                \item[\bf{pipe\_manager.c/h} ---]
                    Contains functions dealing with the piping system that the
                    \tx{eggshell} offers. Also contains a special execution function,
                    rather than using the one found in \tx{proc\_manager.c/h}
            \end{description}
        
        \section{Other files}
            There are also other directories that contain files that aren't
            integral to the functionality of the eggshell, but are still related
            somewhat.

            \begin{description}
                \item[\bf{documentation/} ---]
                    Contains the \tx{.tex} file that generated this report,
                    as well as other items related to it. In order to recompile it,
                    you'd most likely need to install \TeX{}live first.
                \item[\bf{ci/} ---]
                    Unrelated to the main project. The Makefile here is used for 
                    Continuous Integration for the \tx{git} repository.
                \item[\bf{add-on/} ---]
                    Contains the \tx{linenoise.c/h} library that was used in the 
                    main file to simulate a terminal's prompt with input.
                \item[\bf{.vscode/} ---]
                    Contains files that helped with debugging/building the project
                    in \tx{Visual Studio Code}.
            \end{description}

    \clearpage

    \chapter{Code documentation}
        \section{\tx{main.c}}
            \subsection{Use of \tx{main.c}}
                This code is mainly used in order to produce an executable
                using the \tx{eggshell.} This is because the eggshell is
                mainly used as a sort of \tx{API,} which interfaces with
                the inner functions that the eggshell offers.

                As a result, the \tx{main} implements some not-so-integral
                elements of the eggshell, such as an introduction/boot-up
                screen, an additional \tx{test} argument feature, and some
                \tx{linenoise} functions such as history \ii{(ability to
                use $\uparrow$ and $\downarrow$ keys to traverse through
                older commands)}. It also uses the function \tx{updatePrompt();}
                which updates the prompt of the eggshell in order to display
                the current directory.

                A thing to note is that the external command \tx{clear} is run by the line:

                \texttt{runLine(\quot clear\quot, \quot\quot);}

                ...which is an external function found in \tx{eggshell.c}.

                \bb{\myul{Note:}} In order to test the first part of the program,
                which loads \tx{testinput.txt} and runs it, you'd need to run
                the eggshell with the \tx{test} parameter: \tx{./eggshell test}

                \clearpage


        \clearpage

        \section{\tx{eggshell.c}}
            \subsection{Use of \tx{eggshell.c}}
                This file serves as the \bb{core} of the eggshell itself.
                Its main method, \tx{execute}, executes the line inputted
                by the user. Almost every other function of the eggshell is
                accessed through this main file automatically, using parsing.

            \mysubsect{\tx{void initEggshell}}{\tx{()}}
                All this function does is initialise the eggshell. To initialise,
                all it needs to do is initialise its shell variables, which is 
                does by calling the method \tx{initShellVars()} from
                \tx{variables.c}

            \mysubsect{\tx{void runLine}}{\tx{(char *command, char *line)}}
                This function executes the command \tx{command} with the
                arguments found in \tx{line}. An example of this is:

                \tx{command} = \tx{\quot chdir\quot} and \tx{line} = \tx{\quot ../src/\quot}

                Which would execute \tx{chdir} with arguments \tx{../src/}. It does this
                by having a significant if/else-if block that checks which function to execute:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \begin{minted}[gobble=20, breaklines, frame=single, linenos=true]{C}
                    if(strcmp(command, "print") == 0) printLine(line);
                    else if(strcmp(command, "all") == 0) showShellVars();
                    else if(strcmp(command, "vars") == 0) displayUserVars();
                    else if(strcmp(command, "chdir") == 0) changeDirectory(line); 
                    else if(strcmp(command, "source") == 0) runScript(line);
                    else if(strcmp(command, "fg") == 0) resumeProcessSignal(FOREGROUND);
                    else if(strcmp(command, "bg") == 0) resumeProcessSignal(BACKGROUND);
                    else externalCommand(command, line);
                \end{minted}
                \endgroup

                The signal handler is also initialised by calling the \tx{init\_handler()}
                function in \tx{sig\_handler.c}.

                \clearpage
            
            \mysubsect{\tx{void changeDirectory}}{\tx{(char* directory)}}
                This function changes the directory to the directory specified by
                the parameter. This is done using the inbuilt \tx{chdir} function.

                If changing the directory was successful, the \tx{\$CWD} shell
                variable is updated, and the new directory is displayed.

                However, if it was failing, \tx{perror} is used to display the
                error message.
            
            \mysubsect{\tx{void runScript}}{\tx{{(char *filename)}}}
                All this function does, is load a \tx{script} file which can have
                any extension, and execute its commands line by line. It contains
                measures, such as ignoring any line starting with \tx{\#}, or 
                any empty lines. This effectively enables commenting support for 
                scripts using the \tx{\#} symbol.

                It also emulates a prompt, so that the output generated when running 
                the script could be more readable to the user.

                \clearpage
            
            \mysubsect{\tx{void execute}}{\tx{(char *line)}}
                This function is the main one to be executed.
                It is what reveals the eggshell functions to the user,
                as all other functions are accessed via this one.

                What it does first of all, is check the line's structure
                in order to parse it for specific cases. For example, in 
                this section here:
                
                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=27, lastline=32]{../eggshell.c}
                \endgroup
                The first line checks whether the line is identical to the
                exit command \tx{exit}, at which point the \tx{clear} command
                is run, and the program stops executing. Line 30 and 32, use
                functions from \tx{variables.c} and \tx{pipe\_manager.c} respecively,
                to check whether the line assigns a variable, or contains pipes in it.
                An exitcode of 0 from these functions means that they were detected.

                If none of these are detected, the function then attempts to check
                whether the line contains any redirection symbols such as \tx{>},
                \tx{>>}, \tx{<} or \tx{<<<}:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=37, lastline=43]{../eggshell.c}
                \endgroup
                The results of the \tx{strstr} function used are stored in variables.
                These variables have two uses: They are used as flags to check which
                redirection symbol was found, \bb{and} they point to the first character
                of the symbol itself, which is useful. The flag variables \tx{out} and
                \tx{in}, also serve a purpose which will be gone into later on.

                \clearpage

                After this, a conditional \tx{if-else} block is used to parse the line
                for redirection. Depending on which \tx{char*} flags where set, the
                respective function from \tx{redirection.c} is called:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=45, lastline=53]{../eggshell.c}
                \endgroup
                One can also note, that one of the integer flag variables \tx{in/out} is
                also set to 1. This is used to call the appropriate redirection function
                later on.

                After doing so, two lines are used. One uses the \tx{strsep} function to
                seperate the command from the arguments, and the other calls the 
                redirect initialisation function from \tx{redirection.c}

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=55, lastline=58]{../eggshell.c}
                \endgroup
                After this, the actual execution of the function is done. Depending on 
                the integer flags triggered, the appropriate block of code in the
                conditional loop is run. One begins redirecting the input, one redirects
                the output, and in the case that neither of these flags are set, the
                line is simply executed.

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=60, lastline=72]{../eggshell.c}
                \endgroup

        \section{\tx{printer.c}}
            \subsection{Use of \tx{printer.c}}
                This file handles the \tx{print} command. It's main purpose
                is to print the line, being able to detect whether a part of
                the string is escaped in quotation marks, and replacing 
                unescaped variable references with their value.

            \mysubsect{\tx{void printLine}}{\tx{(char *line)}}
                The main function of the file, it is the primary function to
                be called from \tx{printer.c}. It achieves the aforementioned
                goal by splitting the line accordingly, and passing the 
                segments of the split line to the other function in the same file.

                The splitting is done using \tx{strsep}, and an integer variable
                \tx{escaped} was used to determine whether the segment was escaped.

                For example, a line such as:

                \begin{center}
                    hello \$USER, and wel\quot come to the \$HOME\quot
                \end{center}
                
                Will be split into several pieces like:

                \begin{center}
                    hello --- \$USER, --- and --- wel --- come --- to --- the --- \$HOME
                \end{center}

                ...and the segments are then sequentially handed off to the other function.
                Note that after the \tx{wel} segment, the \tx{escaped} variable is flipped.

                \clearpage
            
            \mysubsect{\tx{void printSeg}}{\tx{(char *segment, int escaped)}}
                This function utilises its parameters to print the segment,
                replacing the segment [or a part of it] with a value if it
                is found to be a variable name.

                If the \tx{escape} variable is set to 1, then the segment is
                simply printed without considering the rest of the function.
                However, if it isn't, then the following steps are covered:

                \begin{itemize}
                    \item \bb{IF} the first character is '\$', start reading what's after it.
                        \begin{itemize}
                            \item \bb{IF} the string contains any invalid variable characters
                                \ii{(any character that isn't a capital english letter)},
                                terminate reading, and consider what has been read to be
                                the variable name.
                            \item Retrieve the value of the variable with the name that
                                was read.
                            \item \bb{IF} the variable exists, and the reading was stopped,
                                print the value, followed by the rest of the segment.
                            \item \bb{ELSE IF} the variable exists, and no invalid characters were
                                found, print the value.
                            \item \bb{ELSE}, print the segment.
                        \end{itemize}
                    \item \bb{ELSE}, print the segment.
                \end{itemize}

                For example in the line above, \$USER would be replaced by the value,
                whereas \$HOME would be printed as it is, as it was escaped.

                A limitation of this is that if a segment contains \$ anywhere that isn't
                its first character, it is ignored. For example, if \$A is B, \tx{\$Aees}
                would be printed as \tx{Bees}, whereas \tx{a\$Ae Lincoln} would remain
                the same, instead of being printed as \tx{aBe Lincoln}.

                \clearpage
            
        \section{\tx{sig\_handler.c}}
            \subsection{Use of \tx{sig\_handler.c}}
                This file contains functions relating to any signals, or any effects
                resulting from signals. To be more precise, it contains a \ii{signal handler},
                and a way to wake up a suspended process.

                This was split into a seperate file for sake of organization, as having it
                bundled with the \tx{eggshell.c} file would have added more complexity
                to the already significant file.

            \mysubsect{\tx{void signal\_handler}}{\tx{(int signo)}}
                This is the signal handler that is initialised by \tx{sigaction}.
                
                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=11, lastline=25]{../src/sig_handler.c}
                \endgroup\\[-30pt]
                It is lacking in \tx{printf} statements, as after some research,
                it was found that it is not \tx{re-entrant}, or \tx{async-signal-safe},
                meaning that if, for example, in the middle of running \tx{printf}
                in a signal handler, another signal is caught, the program might 
                end up in a deadlock.

                A \tx{SIGINT} signal is handled by simply sending the signal to the
                current process, whereas a \tx{SIGTSTP} is handled by sending the
                signal, then setting the \tx{resuspended} flag to 1, after which the
                pid of the now suspended process is appended to an array of pid's
                using a variable that keeps count of how many suspended processes there are.
                This ensures that multiple processes can be suspended and restored normally.

                \clearpage
            \mysubsect{\tx{void resumeProcessSignal}}{\tx{{(int state)}}}
                This function activates in the case of either the \tx{fg} or
                \tx{bg} commands. It's purpose is to resume a suspended process
                by calling a function from \tx{proc\_manager.c}. This is done 
                in order to abstract the process managing \ii{(with \tx{waitpid}
                etc...)} from the signal handler, while at the same time allowing
                access to the pid of the suspended process.

                The correct pid is handed off to the function by using the 
                \tx{last\_suspended} variable. This makes process suspension seem
                like a stack, \bb{last suspended, first resumed}. If the suspension
                succeeds, the \tx{last\_suspended} variable is decremented, and the
                exitcode is set to 0. However, if for some reason it does not succeed,
                there are two cases: \ii{the process is unresponsive} or \ii{the process
                was resuspended.} In this case, the exit code is set to reflect which
                outcome happened, \tx{-1} being an error and \tx{18} being an indication
                of another suspension \ii{(18 is the SIGNO of SIGTSTP)}.
            
            \mysubsect{\tx{void init\_handler}}{\tx{()}}
                All this function does is initialise the signal handlers that are to be
                used. It does this by use of \tx{sigaction} rather than \tx{signal},
                for multiple reasons:
                    \begin{itemize}
                        \item \tx{signal} performs differently on different systems,
                            making it an unpredictable function to use.
                        \item \tx{signal} automatically resets the signal action back
                            to \tx{SIG\_DFL} after use. This means that during the time
                            in which the signal is triggered and the handler is 
                            reinitialized, \ii{the system is vulnerable to additional signals,
                            which would not be handled}.
                        \item \tx{sigaction} permits the blocking of signals, which if needed
                            in the future, would be impossible to implement with \tx{signal}
                    \end{itemize}
                
                    Other than the initialisation of the \tx{sigaction} struct, the
                    handler is initialised to deal with \tx{SIGINT} and \tx{SIGTSTP}
                    signals accordingly.

        \section{\tx{redirection.c}}
            \subsection{Use of \tx{redirection.c}}
                The purpose of this file is to handle all \bb{input} and
                \bb{output} redirection. It parses a line for any redirection
                symbols, initialises the redirection using a filename
                \ii{unless \tx{<<<} is detected}, and also starts the redirection,
                depending on its own flags and how they were set.
                
            \subsection{Parsing functions}
                The functions \tx{out\_redirect\_parse} and \tx{in\_redirect\_parse}
                both have very similar code that functions differently in other
                to be more specialised while also simplifying the code from having
                too many conditional blocks.

                Both of them require three strings, \bb{two} specifying pointers
                to the symbols, and \bb{one} which contains the line itself.

                These are passed in the parameter in order for the functions to know
                which action is supposed to happen, and how the line is meant to be
                parsed. This is because, in the case of \tx{<} and \tx{>}, one can 
                simply split according to those symbols and be left with the two
                elements required, albeit with additional whitespace, whereas in the
                case of \tx{<<<} and \tx{>>}, one would need to perform some 
                pointer arithmetic to split the strings accordingly.

                Let's take the \tx{in\_redirect\_parse} function as an example:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=42, lastline=51]{../src/redirection.c}
                \endgroup
                Here, \tx{in\_string} and \tx{in\_file} serve as both pointers to
                the symbol, and flags as to which symbol is present, with
                \tx{in\_string} pointing to \tx{<<<} and \tx{in\_file} pointing to
                \tx{<}. If the former was detected, \tx{filename} is set to a pointer
                \ii{three characters away} from the symbol, whereas if the latter
                was detected instead, \tx{filename} is set to a pointer
                \ii{one character away}. In both cases, the respective flag is also set.

                This ends up setting the filename to whatever is after the symbol, as
                whichever symbol was pushed, the pointer was moved away from it anyways.

                However, this leaves two problems - the left part of the line still
                hasn't been parsed yet, and the start of the filename may still
                contain whitespace.

                These are both solved by the upcoming \tx{strsep} and pointer arithmetic.
                The \tx{line} string, which still points to the whole thing, is split
                according to the \tx{<} delimiter \ii{(\tx{>} for output)}, causing the
                \tx{line} string to now contain only the command. As for the filename,
                it is placed in a loop, where if its first character is a space, its
                pointer is incremented by one. This means that it does not matter how
                many whitespaces are behind the filename, they will all be removed by the
                loop. As for the command, any whitespace at the end will not interfere,
                as the \tx{execution} function in \tx{proc\_manager.c} will ignore those.

            \mysubsect{\tx{int init\_redirect}}{\tx{(char *filename)}}
                All this function does is open the correct file descriptor,
                depending on which flags were set. This is done using an
                integer variable \tx{filefd}, which would hold the descriptor,
                and the \tx{open} function. The differences between \tx{>}
                and \tx{>>>} is simply whether the \tx{O\_TRUNC} macro or the 
                \tx{O\_APPEND} macro is used, and for \tx{<}, it's as simple as
                using \tx{O\_RDONLY}.

                However for \tx{<<<}, the \tx{filename} string would contain an 
                actual string, rather than a filename. As a result, a temporary
                file \tx{stdin.tmp} is created in order to store the string in,
                and the temporary file is then subsequently opened. This has the
                benefit of having the redirection be the same for both \tx{<<<}
                and \tx{<}, abstracting it from the actual redirection function.
                \clearpage
            \subsection{Redirection functions}
                These are grouped together for the same reason the parsing
                functions are. The code is similar, however to avoid 
                unnecessary long conditionals, they were split into two.

                In this case, we'll take the example for the output redirection:
                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=86, lastline=98]{../src/redirection.c}
                \endgroup
                The first \tx{dup} call is used in order to duplicate the file
                descriptor of \tx{stdout} to \tx{save\_out}. This is needed later
                in order to restore \tx{stdout}.

                Then, the \tx{dup2} in the if-condition sets our readymade 
                file descriptor, which was set in the \tx{init\_redirect} function,
                as the replacement for \tx{stdout}. If this fails, the redirection
                aborts, and the error code is reported, as well as the exitcode 
                being set accordingly.

                However if it succeeds, 0 is returned, showing that the redirection
                occured successfully. 

                This differs from \tx{stdin} in that a different variable is used 
                to store the file descriptor for \tx{stdin}, and \tx{stdin} is 
                replaced instead of \tx{stdout}.

                \clearpage

            \mysubsect{\tx{void close\_redirects}}{\tx{(int direction, int filefd)}}
                What this function does is reset all of the redirection that
                was initialised and used so far. It does this by flushing
                \tx{stdout} or \tx{stdin}, depending on which kind of redirection
                occured, and then closing the file descriptor \tx{filefd}.

                Our saved file descriptor, \tx{save\_in/save\_out}, then replaces
                the place our old, now closed file descriptor occupied, after which
                that is closed as well.

                Depending on whether the temporary file was created, it is then
                removed, as we have no more use for it.

                After doing so, to ensure that everything is reset, every single
                flag variable within the file is set to 0, including the
                \tx{save\_out/save\_in} descriptors. This is so that the next time
                redirection happens, it would be as if a redirection never happened
                at all.

                \clearpage

        \section{\tx{proc\_manager.c}}
\end{document}