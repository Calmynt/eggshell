\documentclass[12pt, a4paper]{report}
\usepackage{personalstyle}
\usepackage{gfs artemisia}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}
\setcounter{tocdepth}{1}

\begin{document}
    \begin{titlepage}
        \centering
        \Huge{Eggshell}\\
        \Large{an Operating Systems project}\\
        \normalsize{CPS1012}\\[10pt]
        \Large{Andre' Jenkins}\\
        \small{76999M}
    \end{titlepage}

    \tableofcontents

    \clearpage

    \chapter{Structure of the code}
        The code was structured into different directories, so that they may
        be organised according to what they are supposed to achieve.
        \section{Main files}
            The files here are ones which are used in the front layer of the
            eggshell. Here you may find a main C file that uses the eggshell
            functions, the main eggshell \texttt{.c / .h} files which either
            call multiple other functions, or are simple enough to be on the
            front layer, and other files such as the Makefile, any scripts,
            testfiles, and other miscellaneous files.

            \begin{description}
                \item[\textbf{main.c} --- ]
                    The main \texttt{C} file that the executable is retrieved
                    from. Uses libraries such as \texttt{eggshell} and 
                    \texttt{linenoise}.
                \item[\textbf{eggshell.c/h} ---]
                    The \texttt{eggshell library} used by the main file in order
                    to start the eggshell and utilise it. Uses multiple libraries
                    that are all found in the \texttt{src} directory.
                \item[\textbf{Makefile/Makefile-GCC} ---]
                    The Makefile necessary to generate the executable. The current
                    default Makefile uses the \texttt{Clang} compiler, for reasons
                    stated in the \texttt{README.md} file. To use the Makefile that
                    utilises the \texttt{GCC} compiler instead, either change the
                    name of the \texttt{Makefile-GCC} file, or run \texttt{switch.sh}
                \item[\textbf{switch.sh} ---]
                    A script that aids in switching compilers for the makefile.
                    This was written for each switching between \texttt{Clang} and
                    \texttt{GCC}, due to the ease of debugging with \texttt{Clang},
                    and the standard nature of the \texttt{GCC} compiler.
                \item[\textbf{README.md} ---]
                    The \texttt{README} file holds the instructions to compiling the
                    program, as well as a quick summary of the program and its utilities.
                \item[\textbf{testinput.txt} ---]
                    A file used to test the capabilities of the eggshell. 
                    Running \texttt{./eggshell test} will immediately launch
                    the eggshell and run this script, to provide a quick 
                    testing method.
                \item[\textbf{LICENSE, .gitignore \& .yml files} ---]
                    Files that are unimportant to the project itself.
                    These were used for \texttt{git} purposes, as the project 
                    was also uploaded as a \texttt{git} repository.
            \end{description}

        \section{Source files}
            The files found here are the bulk of the code making up the 
            eggshell. In here, every single \texttt{eggshell header library}
            is present, all of them with their own specific and complicated purpose.
            These were seperated from the main \texttt{eggshell} file 
            in order to organise the core of the project from the 
            specific elements making up the project itself.

            \begin{description}
                \item[\bf{variables.c/h} ---]
                    Contains all the functions and structs relating to the
                    variables created and stored by the \tx{eggshell}. 
                    For example, all the \bb{shell} variables can be found
                    here.
                \item[\bf{printer.c/h} ---]
                    The main file dealing with the \tx{print} command.
                \item[\bf{proc\_manager.c/h} ---]
                    The file dealing with the execution of external commands.
                \item[\bf{sig\_handler.c/h} ---]
                    Contains the \tx{signal handler} function used in order 
                    to suspend and interrupt processes. Also contains an 
                    additional function in order to reawaken a suspended
                    process.
                \item[\bf{redirection.c/h} ---]
                    The main file dealing with \tx{input/output} redirection.
                \item[\bf{pipe\_manager.c/h} ---]
                    Contains functions dealing with the piping system that the
                    \tx{eggshell} offers. Also contains a special execution function,
                    rather than using the one found in \tx{proc\_manager.c/h}
            \end{description}
        
        \section{Other files}
            There are also other directories that contain files that aren't
            integral to the functionality of the eggshell, but are still related
            somewhat.

            \begin{description}
                \item[\bf{documentation/} ---]
                    Contains the \tx{.tex} file that generated this report,
                    as well as other items related to it. In order to recompile it,
                    you'd most likely need to install \TeX{}live first.
                \item[\bf{ci/} ---]
                    Unrelated to the main project. The Makefile here is used for 
                    Continuous Integration for the \tx{git} repository.
                \item[\bf{add-on/} ---]
                    Contains the \tx{linenoise.c/h} library that was used in the 
                    main file to simulate a terminal's prompt with input.
                \item[\bf{.vscode/} ---]
                    Contains files that helped with debugging/building the project
                    in \tx{Visual Studio Code}.
            \end{description}

    \clearpage

    \chapter{Code documentation}
        \section{\tx{main.c}}
            \subsection{Use of \tx{main.c}}
                This code is mainly used in order to produce an executable
                using the \tx{eggshell.} This is because the eggshell is
                mainly used as a sort of \tx{API,} which interfaces with
                the inner functions that the eggshell offers.

                As a result, the \tx{main} implements some not-so-integral
                elements of the eggshell, such as an introduction/boot-up
                screen, an additional \tx{test} argument feature, and some
                \tx{linenoise} functions such as history \ii{(ability to
                use $\uparrow$ and $\downarrow$ keys to traverse through
                older commands)}. It also uses the function \tx{updatePrompt();}
                which updates the prompt of the eggshell in order to display
                the current directory.

                A thing to note is that the external command \tx{clear} is run by the line:

                \texttt{runLine(\quot clear\quot, \quot\quot);}

                ...which is an external function found in \tx{eggshell.c}.

                \bb{\myul{Note:}} In order to test the first part of the program,
                which loads \tx{testinput.txt} and runs it, you'd need to run
                the eggshell with the \tx{test} parameter: \tx{./eggshell test}

                \clearpage


        \clearpage

        \section{\tx{eggshell.c}}
            \subsection{Use of \tx{eggshell.c}}
                This file serves as the \bb{core} of the eggshell itself.
                Its main method, \tx{execute}, executes the line inputted
                by the user. Almost every other function of the eggshell is
                accessed through this main file automatically, using parsing.

            \mysubsect{\tx{void initEggshell}}{\tx{()}}
                All this function does is initialise the eggshell. To initialise,
                all it needs to do is initialise its shell variables, which is 
                does by calling the method \tx{initShellVars()} from
                \tx{variables.c}

            \mysubsect{\tx{void runLine}}{\tx{(char *command, char *line)}}
                This function executes the command \tx{command} with the
                arguments found in \tx{line}. An example of this is:

                \tx{command} = \tx{\quot chdir\quot} and \tx{line} = \tx{\quot ../src/\quot}

                Which would execute \tx{chdir} with arguments \tx{../src/}. It does this
                by having a significant if/else-if block that checks which function to execute:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \begin{minted}[gobble=20, breaklines, frame=single, linenos=true]{C}
                    if(strcmp(command, "print") == 0) printLine(line);
                    else if(strcmp(command, "all") == 0) showShellVars();
                    else if(strcmp(command, "vars") == 0) displayUserVars();
                    else if(strcmp(command, "chdir") == 0) changeDirectory(line); 
                    else if(strcmp(command, "source") == 0) runScript(line);
                    else if(strcmp(command, "fg") == 0) resumeProcessSignal(FOREGROUND);
                    else if(strcmp(command, "bg") == 0) resumeProcessSignal(BACKGROUND);
                    else externalCommand(command, line);
                \end{minted}
                \endgroup

                The signal handler is also initialised by calling the \tx{init\_handler()}
                function in \tx{sig\_handler.c}.

                \clearpage
            
            \mysubsect{\tx{void changeDirectory}}{\tx{(char* directory)}}
                This function changes the directory to the directory specified by
                the parameter. This is done using the inbuilt \tx{chdir} function.

                If changing the directory was successful, the \tx{\$CWD} shell
                variable is updated, and the new directory is displayed.

                However, if it was failing, \tx{perror} is used to display the
                error message.
            
            \mysubsect{\tx{void runScript}}{\tx{{(char *filename)}}}
                All this function does, is load a \tx{script} file which can have
                any extension, and execute its commands line by line. It contains
                measures, such as ignoring any line starting with \tx{\#}, or 
                any empty lines. This effectively enables commenting support for 
                scripts using the \tx{\#} symbol.

                It also emulates a prompt, so that the output generated when running 
                the script could be more readable to the user.

                \bb{\myul{Important Note:}} \tx{fgets} with a buffer was used to 
                store all the lines into a buffer array, after which the lines from
                said array will be loaded one by one. This approach was chosen over
                using \tx{fgets} directly because of a \bb{critical} issue that 
                surfaced when the source file contained an invalid line.

                The invalid line would attempt to be executed as an \tx{external command},
                after which the \tx{execve} would fail, causing the function that handles
                external commands to \tx{\_exit}. This function not only effectively 
                terminates the child, but also \bb{resets all file pointers}.

                This effectively duplicated the execution of every consecutive command in
                the file. Not only that, but if \bb{two} invalid commands were used, the
                \tx{source} command would lock the \tx{eggshell} into an uninterruptable loop
                that requires a \tx{SIGKILL} signal to halt.

                \clearpage
            
            \mysubsect{\tx{void execute}}{\tx{(char *line)}}
                This function is the main one to be executed.
                It is what reveals the eggshell functions to the user,
                as all other functions are accessed via this one.

                What it does first of all, is check the line's structure
                in order to parse it for specific cases. For example, in 
                this section here:
                
                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=27, lastline=32]{../eggshell.c}
                \endgroup
                The first line checks whether the line is identical to the
                exit command \tx{exit}, at which point the \tx{clear} command
                is run, and the program stops executing. Line 30 and 32, use
                functions from \tx{variables.c} and \tx{pipe\_manager.c} respecively,
                to check whether the line assigns a variable, or contains pipes in it.
                An exitcode of 0 from these functions means that they were detected.

                If none of these are detected, the function then attempts to check
                whether the line contains any redirection symbols such as \tx{>},
                \tx{>>}, \tx{<} or \tx{<<<}:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=37, lastline=43]{../eggshell.c}
                \endgroup
                The results of the \tx{strstr} function used are stored in variables.
                These variables have two uses: They are used as flags to check which
                redirection symbol was found, \bb{and} they point to the first character
                of the symbol itself, which is useful. The flag variables \tx{out} and
                \tx{in}, also serve a purpose which will be gone into later on.

                \clearpage

                After this, a conditional \tx{if-else} block is used to parse the line
                for redirection. Depending on which \tx{char*} flags where set, the
                respective function from \tx{redirection.c} is called:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=45, lastline=53]{../eggshell.c}
                \endgroup
                One can also note, that one of the integer flag variables \tx{in/out} is
                also set to 1. This is used to call the appropriate redirection function
                later on.

                After doing so, two lines are used. One uses the \tx{strsep} function to
                seperate the command from the arguments, and the other calls the 
                redirect initialisation function from \tx{redirection.c}

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=55, lastline=58]{../eggshell.c}
                \endgroup
                After this, the actual execution of the function is done. Depending on 
                the integer flags triggered, the appropriate block of code in the
                conditional loop is run. One begins redirecting the input, one redirects
                the output, and in the case that neither of these flags are set, the
                line is simply executed.

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=60, lastline=72]{../eggshell.c}
                \endgroup

        \section{\tx{printer.c}}
            \subsection{Use of \tx{printer.c}}
                This file handles the \tx{print} command. It's main purpose
                is to print the line, being able to detect whether a part of
                the string is escaped in quotation marks, and replacing 
                unescaped variable references with their value.

            \mysubsect{\tx{void printLine}}{\tx{(char *line)}}
                The main function of the file, it is the primary function to
                be called from \tx{printer.c}. It achieves the aforementioned
                goal by splitting the line accordingly, and passing the 
                segments of the split line to the other function in the same file.

                The splitting is done using \tx{strsep}, and an integer variable
                \tx{escaped} was used to determine whether the segment was escaped.

                For example, a line such as:

                \begin{center}
                    hello \$USER, and wel\quot come to the \$HOME\quot
                \end{center}
                
                Will be split into several pieces like:

                \begin{center}
                    hello --- \$USER, --- and --- wel --- come --- to --- the --- \$HOME
                \end{center}

                ...and the segments are then sequentially handed off to the other function.
                Note that after the \tx{wel} segment, the \tx{escaped} variable is flipped.

                \clearpage
            
            \mysubsect{\tx{void printSeg}}{\tx{(char *segment, int escaped)}}
                This function utilises its parameters to print the segment,
                replacing the segment [or a part of it] with a value if it
                is found to be a variable name.

                If the \tx{escape} variable is set to 1, then the segment is
                simply printed without considering the rest of the function.
                However, if it isn't, then the following steps are covered:

                \begin{itemize}
                    \item \bb{IF} the first character is '\$', start reading what's after it.
                        \begin{itemize}
                            \item \bb{IF} the string contains any invalid variable characters
                                \ii{(any character that isn't a capital english letter)},
                                terminate reading, and consider what has been read to be
                                the variable name.
                            \item Retrieve the value of the variable with the name that
                                was read.
                            \item \bb{IF} the variable exists, and the reading was stopped,
                                print the value, followed by the rest of the segment.
                            \item \bb{ELSE IF} the variable exists, and no invalid characters were
                                found, print the value.
                            \item \bb{ELSE}, print the segment.
                        \end{itemize}
                    \item \bb{ELSE}, print the segment.
                \end{itemize}

                For example in the line above, \$USER would be replaced by the value,
                whereas \$HOME would be printed as it is, as it was escaped.

                A limitation of this is that if a segment contains \$ anywhere that isn't
                its first character, it is ignored. For example, if \$A is B, \tx{\$Aees}
                would be printed as \tx{Bees}, whereas \tx{a\$Ae Lincoln} would remain
                the same, instead of being printed as \tx{aBe Lincoln}.

                \clearpage
            
        \section{\tx{sig\_handler.c}}
            \subsection{Use of \tx{sig\_handler.c}}
                This file contains functions relating to any signals, or any effects
                resulting from signals. To be more precise, it contains a \ii{signal handler},
                and a way to wake up a suspended process.

                This was split into a seperate file for sake of organization, as having it
                bundled with the \tx{eggshell.c} file would have added more complexity
                to the already significant file.\\[-30pt]

            \mysubsect{\tx{void signal\_handler}}{\tx{(int signo)}}
                This is the signal handler that is initialised by \tx{sigaction}.
                
                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=11, lastline=25]{../src/sig_handler.c}
                \endgroup\\[-30pt]
                It is lacking in \tx{printf} statements, as after some research,
                it was found that it is not \tx{re-entrant}, or \tx{async-signal-safe},
                meaning that if, for example, in the middle of running \tx{printf}
                in a signal handler, another signal is caught, the program might 
                end up in a deadlock.

                A \tx{SIGINT} signal is handled by simply sending the signal to the
                current process, whereas a \tx{SIGTSTP} is handled by sending the
                signal, then setting the \tx{resuspended} flag to 1, after which the
                pid of the now suspended process is appended to an array of pid's
                using a variable that keeps count of how many suspended processes there are.
                This ensures that multiple processes can be suspended and restored normally.

                \clearpage
            \mysubsect{\tx{void resumeProcessSignal}}{\tx{{(int state)}}}
                This function activates in the case of either the \tx{fg} or
                \tx{bg} commands. It's purpose is to resume a suspended process
                by calling a function from \tx{proc\_manager.c}. This is done 
                in order to abstract the process managing \ii{(with \tx{waitpid}
                etc...)} from the signal handler, while at the same time allowing
                access to the pid of the suspended process.

                The correct pid is handed off to the function by using the 
                \tx{last\_suspended} variable. This makes process suspension seem
                like a stack, \bb{last suspended, first resumed}. If the suspension
                succeeds, the \tx{last\_suspended} variable is decremented, and the
                exitcode is set to 0. However, if for some reason it does not succeed,
                there are two cases: \ii{the process is unresponsive} or \ii{the process
                was resuspended.} In this case, the exit code is set to reflect which
                outcome happened, \tx{-1} being an error and \tx{18} being an indication
                of another suspension \ii{(18 is the SIGNO of SIGTSTP)}.
            
            \mysubsect{\tx{void init\_handler}}{\tx{()}}
                All this function does is initialise the signal handlers that are to be
                used. It does this by use of \tx{sigaction} rather than \tx{signal},
                for multiple reasons:
                    \begin{itemize}
                        \item \tx{signal} performs differently on different systems,
                            making it an unpredictable function to use.
                        \item \tx{signal} automatically resets the signal action back
                            to \tx{SIG\_DFL} after use. This means that during the time
                            in which the signal is triggered and the handler is 
                            reinitialized, \ii{the system is vulnerable to additional signals,
                            which would not be handled}.
                        \item \tx{sigaction} permits the blocking of signals, which if needed
                            in the future, would be impossible to implement with \tx{signal}
                    \end{itemize}
                
                    Other than the initialisation of the \tx{sigaction} struct, the
                    handler is initialised to deal with \tx{SIGINT} and \tx{SIGTSTP}
                    signals accordingly.

        \section{\tx{redirection.c}}
            \subsection{Use of \tx{redirection.c}}
                The purpose of this file is to handle all \bb{input} and
                \bb{output} redirection. It parses a line for any redirection
                symbols, initialises the redirection using a filename
                \ii{unless \tx{<<<} is detected}, and also starts the redirection,
                depending on its own flags and how they were set.
                
            \subsection{Parsing functions}
                The functions \tx{out\_redirect\_parse} and \tx{in\_redirect\_parse}
                both have very similar code that functions differently in other
                to be more specialised while also simplifying the code from having
                too many conditional blocks.

                Both of them require three strings, \bb{two} specifying pointers
                to the symbols, and \bb{one} which contains the line itself.

                These are passed in the parameter in order for the functions to know
                which action is supposed to happen, and how the line is meant to be
                parsed. This is because, in the case of \tx{<} and \tx{>}, one can 
                simply split according to those symbols and be left with the two
                elements required, albeit with additional whitespace, whereas in the
                case of \tx{<<<} and \tx{>>}, one would need to perform some 
                pointer arithmetic to split the strings accordingly.

                Let's take the \tx{in\_redirect\_parse} function as an example:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=42, lastline=51]{../src/redirection.c}
                \endgroup
                Here, \tx{in\_string} and \tx{in\_file} serve as both pointers to
                the symbol, and flags as to which symbol is present, with
                \tx{in\_string} pointing to \tx{<<<} and \tx{in\_file} pointing to
                \tx{<}. If the former was detected, \tx{filename} is set to a pointer
                \ii{three characters away} from the symbol, whereas if the latter
                was detected instead, \tx{filename} is set to a pointer
                \ii{one character away}. In both cases, the respective flag is also set.

                This ends up setting the filename to whatever is after the symbol, as
                whichever symbol was pushed, the pointer was moved away from it anyways.

                However, this leaves two problems - the left part of the line still
                hasn't been parsed yet, and the start of the filename may still
                contain whitespace.

                These are both solved by the upcoming \tx{strsep} and pointer arithmetic.
                The \tx{line} string, which still points to the whole thing, is split
                according to the \tx{<} delimiter \ii{(\tx{>} for output)}, causing the
                \tx{line} string to now contain only the command. As for the filename,
                it is placed in a loop, where if its first character is a space, its
                pointer is incremented by one. This means that it does not matter how
                many whitespaces are behind the filename, they will all be removed by the
                loop. As for the command, any whitespace at the end will not interfere,
                as the \tx{execution} function in \tx{proc\_manager.c} will ignore those.

            \mysubsect{\tx{int init\_redirect}}{\tx{(char *filename)}}
                All this function does is open the correct file descriptor,
                depending on which flags were set. This is done using an
                integer variable \tx{filefd}, which would hold the descriptor,
                and the \tx{open} function. The differences between \tx{>}
                and \tx{>>>} is simply whether the \tx{O\_TRUNC} macro or the 
                \tx{O\_APPEND} macro is used, and for \tx{<}, it's as simple as
                using \tx{O\_RDONLY}.

                However for \tx{<<<}, the \tx{filename} string would contain an 
                actual string, rather than a filename. As a result, a temporary
                file \tx{stdin.tmp} is created in order to store the string in,
                and the temporary file is then subsequently opened. This has the
                benefit of having the redirection be the same for both \tx{<<<}
                and \tx{<}, abstracting it from the actual redirection function.
                \clearpage
            \subsection{Redirection functions}
                These are grouped together for the same reason the parsing
                functions are. The code is similar, however to avoid 
                unnecessary long conditionals, they were split into two.

                In this case, we'll take the example for the output redirection:
                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=86, lastline=98]{../src/redirection.c}
                \endgroup
                The first \tx{dup} call is used in order to duplicate the file
                descriptor of \tx{stdout} to \tx{save\_out}. This is needed later
                in order to restore \tx{stdout}.

                Then, the \tx{dup2} in the if-condition sets our readymade 
                file descriptor, which was set in the \tx{init\_redirect} function,
                as the replacement for \tx{stdout}. If this fails, the redirection
                aborts, and the error code is reported, as well as the exitcode 
                being set accordingly.

                However if it succeeds, 0 is returned, showing that the redirection
                occured successfully. 

                This differs from \tx{stdin} in that a different variable is used 
                to store the file descriptor for \tx{stdin}, and \tx{stdin} is 
                replaced instead of \tx{stdout}.

                \clearpage

            \mysubsect{\tx{void close\_redirects}}{\tx{(int direction, int filefd)}}
                What this function does is reset all of the redirection that
                was initialised and used so far. It does this by flushing
                \tx{stdout} or \tx{stdin}, depending on which kind of redirection
                occured, and then closing the file descriptor \tx{filefd}.

                Our saved file descriptor, \tx{save\_in/save\_out}, then replaces
                the place our old, now closed file descriptor occupied, after which
                that is closed as well.

                Depending on whether the temporary file was created, it is then
                removed, as we have no more use for it.

                After doing so, to ensure that everything is reset, every single
                flag variable within the file is set to 0, including the
                \tx{save\_out/save\_in} descriptors. This is so that the next time
                redirection happens, it would be as if a redirection never happened
                at all.

                \clearpage

        \section{\tx{proc\_manager.c}}
            \subsection{Use of \tx{proc\_manager.c}}
                The use of this file is to manage everything doing
                with processes. This includes a \tx{fork-exec} pattern
                for external commands and handling the resumption of
                suspended processes.
            
            \mysubsect{\tx{char** pathsToCommArr}}{\tx{(int *pathn, char *program)}}
                This function is meant to be a \ii{helper} to the main 
                function of the file, as it produces an array of possible
                \tx{PATH}s that show where the product is.

                Firstly, the \tx{PATH} variable is retrieved, and copied
                into a seperate string, so that any modifications to the
                new string do not reflect back to our shell variable.
                Then, the array of paths is created and initialised.

                After doing so, we have the following code:

                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=99, lastline=116]{../src/proc_manager.c}
                \endgroup

                The delimiter's purpose is to store what we will be splitting
                the paths by --- the colon. \tx{pathnL} will also be the
                temporary variable in which we'll store the amount of paths.

                Inside the loop, \tx{path} will store the freshly seperated
                path from the \tx{paths} string, at which point it is stored
                in the \tx{patharr} array. Said path then has \tx{/<program name>}
                appended to it, as that would be the possible full path of the 
                program.

                After doing so, the path array is reallocated some additional
                memory in advance, so that it would be able to store an additional
                path. 

                Once the loop breaks, the parameter \tx{*pathn} is set to
                \tx{pathnL}. This is so that the length of the paths can be used
                outside this function. After doing so, the array of paths is then
                returned.

            \mysubsect{\tx{void externalCommand}}{\tx{(char *command, char *varargs)}}
                This function executes a command that does not belong to the
                \tx{eggshell} using \tx{fork-exec}. The parameters are the name 
                of the command itself, and a single string containing all the 
                arguments of the command. A command with no arguments will have 
                an empty string as \tx{varargs}.

                The function first initialises all the variables it will need:

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=14, lastline=28]{../src/proc_manager.c}
                \endgroup\\

                Here's a small description for each of these variables:
                
                \begin{description}
                    \item[\tx{args} --- ] 
                        Where the array of arguments will be stored.
                    \item[\tx{arg} --- ]
                        Temporary variable used to store the argument to be 
                        added to \tx{args}
                    \item[\tx{argc} --- ]
                        The number of arguments present.
                    \item[\tx{arg\_delimiter[2]} --- ]
                        Used to split the \tx{varargs} string into individual
                        arguments
                    \item[\tx{BG} --- ]
                        Flag whose purpose is to signal whether the process should
                        be run in the background or foreground. 0 means foreground.
                    \item[\tx{envp} --- ]
                        Contains all environment variables, the ones belonging to
                        the main shell, \bb{and} \tx{eggshell} variables.
                    \item[\tx{pid} --- ]
                        Stores the process id of the forked process.
                    \item[\tx{pathn} --- ]
                        Contains the amount of paths that are present in \tx{paths}
                    \item[\tx{paths} --- ]
                        The array of paths to cycle through when executing a command. 
                \end{description}

                The following loop then splits \tx{varargs} into \tx{args}
                using the \tx{arg\_delimiter}, after which the main 
                conditional block is encountered.

                Here, there are three possibilities. We are in the child,
                we are in the parent, or the forking failed. First, we will
                consider the child.

                For the child, it is pretty simple. The first argument in
                \tx{args} is set to the current \tx{path} we are attempting
                to access, and the numerous paths are cycled through until 
                the program is found and then executed, or all the paths are
                exhausted and an error message is returned. \tx{\_exit()}
                was used rather than \tx{exit()}, as the latter was causing
                issues when combined with the \tx{source} command.

                For the parent, it is slightly more complicated.
                First, the \tx{current\_pid} global variable is set to the pid
                of the process to be used by the signal handler, and then the 
                \tx{pgid} of the forked process is set to itself. This means that
                if a signal is recieved, the signal sent by the signal handler
                will only affect the current process running in the \tx{foreground}.
                If this line was omitted, all children would receive the same signal,
                even ones who are suspended or in the background.

                After doing so, an if block will execute if \tx{\&} was not detected
                at the end of \tx{varargs}. If it was, the function will ignore this
                block, hence letting the process run in the background. However if it
                wasn't, the parent will wait for the process to finish:

                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=65, lastline=76]{../src/proc_manager.c}
                \endgroup

                The \tx{status} variable stores the status code of how the process
                terminated. The \tx{WIFEXITED} and \tx{WIFSIGNALED} macros check
                whether the process terminated normally or with a signal. Then, 
                \tx{WEXITSTATUS(status)} or \tx{WTERMSIG(status)} will show us 
                the exitcode of the process, or the signal that stopped the process
                respectively.

                \tx{WUNTRACED} was used in \tx{waitpid} as it waits for the process
                to finish, however if the process is suspended, it will immediately
                stop waiting and continue on. After this point, the function will then
                return.

                If, however, the forking failed, \tx{perror} is used to showcase why
                that is the case.

                \clearpage

            \mysubsect{\tx{int resumeProcess}}{\tx{(int state, pid\_t process)}}
                The purpose of this function is to resume a previously suspended 
                process. This is done by using the \tx{pid\_t} given in the parameter,
                and checking whether the program should be resumed in the foreground
                or background using the \tx{state} variable.

                Firstly, the \tx{resuspended} variable is reset to 0, after which a
                \tx{SIGCONT} signal is sent to the suspended process. If this failed,
                \tx{perror} is used to show why, and an error code of 1 is returned.

                If it doesn't fail, the \tx{current\_pid} is then set to the now
                recovered process. The same waiting conditional block that was in
                \tx{externalCommand} is placed here, depending on whether 
                \tx{state} was set to the macro \tx{FOREGROUND} or \tx{BACKGROUND}.

                There is an extra step however. \tx{resuspended} is checked again,
                to know whether the resumed process was suspended again. If it is
                still set to 0, then an exitcode of 0 is returned, showing everything
                executed normally. However, if it is now set to 1, an exitcode of 
                18 is returned, showing that the process was suspended again.
                This number was chosen because it is the signal number of \tx{SIGTSTP}.

                \bb{\myul{Note:}} The \tx{currentPid} function is omitted from the
                documentation as its function is obvious, and it only contains one
                line of code as a result. Its only purpose is to make a variable
                accessible by other files.

                \clearpage
                
        \section{\tx{variables.c}}
            \subsection{Use of \tx{variables.c}}
                This file handles everything to do with variables.
                This includes assignment, modification, retrieval,
                and manipulation. It also helps initialise the
                \tx{eggshell} by setting the shell variables.
                It is one of the most used files in the system, as
                multiple other functions require the use of variables,
                whether it be as a \tx{struct} or just their values.

            \mysubsect{\tx{int parse\_var}}{\tx{(char *line)}}
                This function detects whether the line passed is
                attempting to assign a variable, or modify its value.
                It also validates the line, stopping the function if
                the assignment detected seems to be invalid.
                There are three rules for valid assignment:

                \begin{itemize}
                    \item The variable name should be \bb{capitalised}
                    \item No spaces should surround the \tx{=} symbol.
                    \item The variable name cannot have whitespace.
                \end{itemize}

                These rules are put into place as they are the same
                syntax rules used by the \tx{bash shell}.

                First, we start with the assumption that the line \bb{is}
                an assignment line, and then proceed to \bb{use} or
                \bb{validate} it:

                \begingroup
                    \fontsize{10pt}{10pt}\selectfont
                    \Ccode[firstline=11, lastline=18]{../src/variables.c}
                \endgroup

                We copy the line into \tx{vartest} so as to not modify it, and then
                we split the line into two, storing the supposed right side into
                \tx{vartest}, and the left side in \tx{varname}. It should stand to
                reason that, a line which does not have the \tx{=} symbol is not
                trying to achieve assignment. Therefore the first check is whether
                \tx{vartest} is empty. 

                The second check is whether \tx{vartest} starts with whitespace,
                \ii{and} whether \tx{varname} has any spaces within it at all.
                Followed by a third check that checks all the letters within
                \tx{varname} to see whether they are all capitalised. This is done
                using the capital-letter slice in the ASCII table.

                If any of these checks fail, \tx{1} is returned, meaning that
                the line should continue to be parsed, incase it should be treated
                as a command instead.

                If they all succeed however, the \tx{createVar} function is called 
                in order to either create, or modify a variable.

            \mysubsect{\tx{void createVar}}{\tx{(char *line)}}
                This is the largest function in the file, due to the
                sheer amount of possibilities that the assignment is
                attempting to achieve, such as:
                
                \begin{itemize}
                    \item Create a new variable with a string value.
                    \item Create a new variable with the value of an existing variable.
                    \item Modify an existing variable with a string value.
                    \item Replace an existing variable with the value of a different one.
                \end{itemize}

                Each of these possibilities need to be handled, and some even have
                error cases, for example, the variable name in the righthand side of the
                line does not exist, hence the assignment is aborted.

                Firstly, the name and value of the variable are retrieved from the line,
                and the name is checked to belong to an existing variable. This is done
                by attempting to retrieve a variable with the same name. Needless to say,
                if something is returned, then the name belongs to an existing variable.
                If nothing is returned, then a new variable should be created.

                Considering something is returned, the first character of the right hand
                side is checked to be a \tx{\$}, the symbol seperating a variable from
                a normal string. If it isn't, then simply set the variable value to 
                the string as normal. However if it is, then the variable with the name
                after \tx{\$} is retrieved. If said variable does not exist, then the 
                function displays an error, along with returning immediately. However if
                the variable exists, the value of the old variable is overwritten with 
                the value of the new one. After doing so, the function returns with 
                a successful code.

                After doing so, possibilities 3 and 4 have been handled. Now it's time
                to handle the case when a new variable should be created.

                In the case that the first character of the right hand side is found to
                be \tx{\$}, the same thing as before happens, only the function does not
                return at the end, and the value overwritten is the right hand side of the line.

                After doing so, the new variable is initialised by allocating memory to the 
                empty space in the \tx{variable array}. Then, the now initialised
                empty space in the array will be set to hold the newly created variable.
                The following code will then reallocate enough additional memory to the
                \tx{variable array} to be able to hold an additional variable the next time
                around, and the \tx{integer variable} showing the amount of variables in the
                array is incremented.

                After doing so, possibilities 1 and 2 have now also been handled.
                All that is left is the next block of code, which checks whether the 
                \tx{\$EXITCODE} variable exists, and sets it if it does. This is
                important as at the start of the eggshell, when it is being initialised,
                numerous variable will be initialised before the \tx{EXITCODE}. If the 
                function tries to set the exitcode before the exitcode is even created,
                that would cause a segmentation fault.
                \clearpage
            
            \mysubsect{\tx{void initShellVars}}{\tx{(char *ex)}}
                This function serves to initialise the environment variables that
                will be used and stored by the \tx{eggshell}. Said variables occupy
                the first 8 spaces of the \tx{variables} array, making it easy to
                differentiate between the \tx{environment} variables and the 
                \tx{user-made} variables.

                The first thing the function does is initialise the \tx{SHELL} and 
                the \tx{CWD} variables. This is because they have distinct ways of
                initialising them when compared to the other variables. 
                \tx{SHELL} utilises the personal \tx{getExecPath} function, whereas
                \tx{CWD} uses the inbuilt \tx{getcwd} function.

                After doing this, the variables array is initialised, in order to start
                storing the shell variables. Since the \tx{createVar} expects a formatted
                string of \tx{<VARNAME>=<VALUE>}, we'd need to pass a preformatted string
                as the parameter. To do so, 8 variables are initialised.

                Using \tx{sprintf} and functions to retrieve the rest of the environment 
                variables, the \tx{8} \ii{injection strings} are formatted into a string
                that will be processed by \tx{createVar}. After doing so, all 8 strings
                are passed to the function in order to create the variables. Once this
                is finished, all temporary strings are then freed.
            \mysubsect{\tx{char** environEGG}}{\tx{()}}
                This function returns a character array of all environment variables,
                including the ones from the shell and eggshell. It does this by 
                retrieving \tx{extern char **environ} and using \tx{setenv} in order
                to place our variables in \tx{environ}. \tx{setenv} was used over
                \tx{getenv} as the latter uses the \bb{pointer} to the string, 
                complicating matters the same string was used to place multiple
                variables.
                \clearpage
            \subsection{Retrieval and \tx{value} functions}
                The following functions are used to retrieve either a variable struct,
                mostly for modification, or the value of the variable:

                \begin{itemize}
                    \item \tx{int varExists(char *varname)}
                    \item \tx{Var* retrieveVar(char *varname)}
                    \item \tx{char *value(char *varname)}
                \end{itemize}

                The first function serves as a helper to the other two functions.
                What it does is check whether a variable with the name \tx{varname}
                exists in the array, and returns its index, with \tx{-1} being returned
                if no such variable exists. This is done using a simple loop.

                The second function uses the first to check whether a variable with
                that name exists, and using the index returned, either the variable 
                is returned, or \tx{0} is. In other words, \tx{retrieveVar} is a 
                more useful version of \tx{varExists} for other functions.

                The third function uses the second to check whether a variable with
                said name exists, and using the variable returned, returns its value.
                If such a variable does not exist, \tx{0} is returned instead.

                Each function is a step over the other, which allows the user to pick
                the right one depending on what they need precisely.

            \subsection{Display functions}
                There are two functions that display variables. These were seperate for
                the \tx{all} and \tx{vars} commands to have a simple way of executing:

                \begin{itemize}
                    \item \tx{void showShellVars()}
                    \item \tx{void displayUserVars()}
                \end{itemize}

                The former was done using a combination of \tx{printf} and the \tx{value}
                functions. The latter consisted of a loop that traversed the variable array
                while also excluding the environment variables.
                \clearpage

            \subsection{Get, Set, and Update functions}
                The purpose of these functions is to either \bb{get} a value, in
                order to initialise the shell variables, \bb{set} a value easily,
                as the value would be modified frequently, and \bb{update} a value,
                due to them requiring frequent updates for numerous reasons.
                Such functions include

                \begin{itemize}
                    \item \tx{char* getExecPath(char *ex)}
                    \item \tx{void setExitcode(int ec)}
                    \item \tx{void updateCWD()}
                    \item \tx{void updatePrompt()}
                \end{itemize}
 
                The first function utilises the parameter, and the current working directory,
                to construct the path that the \tx{eggshell} is being executed in.

                The parameter is meant to be \tx{argv[0]}, which is the exact command used to
                launch the \tx{eggshell}. Depending on whether the relative path 
                \ii{\tx{(./eggshell)}} or the absolute path \ii{\tx{(/???/eggshell)}} was used,
                the path is then constructed by either keeping the absolute path, or 
                concatenating the \tx{CWD} with the relative path. After doing this,
                \tx{realpath} is used to resolve the path, in case relative symbols 
                remain in it.

                The second function converts the integer given in the parameter to a string,
                and then sets the value of the \tx{\$EXITCODE} variable to it.

                The third and fourth function "reinitialise" the \tx{\$CWD} and \tx{\$PROMPT}
                variables using similar means than what was used before to first initialise 
                them. These are important to update as \tx{\$CWD} needs to update to reflect
                the effects of \tx{chdir}, and \tx{\$PROMPT} needs to update to reflect the
                changes in \tx{\$CWD} and \tx{\$EXITCODE}.
                \clearpage

        \section{\tx{pipe\_manager.c}}
            \subsection{Use of \tx{pipe\_manager.c}}
                This file manages everything to do with the piping 
                functionality that the program offers. This includes
                parsing a line for pipes, and then piping the output
                of one command into the piping of the input. 
                As a result, only two functions are present, one for
                the parsing, and another for the actual piping mechanic.

            \mysubsect{\tx{int pipe\_parser}}{\tx{(char *line)}}
                This function parses a line to detect any piping symbols,
                and uses the specialized \tx{piping execute} function
                if such symbols are detected.

                The detection is as simple as using \tx{strstr} to detect
                \tx{|}, returning \tx{1} if the function returns a null pointer.
                If it doesn't fail however, the line given will then be split
                according to the pipe symbols, placing them in an array of 
                strings which are then passed onto the \tx{execute} function.

                The parse function aids the execution function as well, in that
                it sets global variables, showing how many pipes/commands there
                are within the line.
                \clearpage

            \mysubsect{\tx{int pipe\_executer}}{\tx{(char **commands)}}
                This function requires an array of commands given by the \tx{parsing}
                function. One could fake an array, but the function will still fail
                due to the global variables not being initialized.

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=59, lastline=67]{../src/pipe_manager.c}
                \endgroup

                The following crafts an array of integers, which will be used to 
                initialize pipes using the \tx{pipe} function. An array of specialized
                \tx{pipeAmnt*2} is required due to every pipe requiring an \ii{input}
                and an \ii{output}. Meaning that for a command with 3 pipes, an array
                of six integers is crafted, \tx{piping} every two spaces.

                After this, three important variables are declared.
                \tx{j} is used to iterate through all the commands,
                \tx{p} is used to iterate through all the pipes within the array,
                and \tx{pid} is used to store the process id of the current process.

                The first loop then starts, used to iterate through all the commands.
                What follows is then command specific - the current command is split into
                the command itself and its arguments, which are placed in a single string.
                After this, the string is copied into a seperate variable, before being
                split up and stored in a string array to be used as arguments.

                A process is then forked, and a conditional loop follows that seperates 
                the child from the parent.

                \clearpage

                \bb{\myul{Child --- Forking}}

                \begingroup
                \fontsize{10pt}{10pt}\selectfont
                \Ccode[firstline=106, lastline=127]{../src/pipe_manager.c}
                \endgroup

                The following blocks are complicated. Firstly, the command is checked
                to be either the \bb{first} or the \bb{last} command in the array.
                If it is the \ii{first}, then only its pipe's output is wired to its \tx{stdout}.
                If it is the \ii{last}, then only the previous's pipe's input is wired to its \tx{stdin}.
                If it is neither, then both of these steps occur.

                To explain further, lets say we have 3 commands, \tx{a, b} and \tx{c}.

                a outputs \tx{\quot Hello World! \quot}. This is wired to the \tx{stdout} of \tx{PIPE 1}.
                b takes the input, and repeats it. It gathers its input from the \tx{stdin} of \tx{PIPE 1},
                and places it into the \tx{stdout} of \tx{PIPE 2}. In the previous pipe, \tx{\quot Hello World! \quot}
                remains, so that is used as input. c then takes the input, and displays how many characters there
                are. It gathers the input from \tx{PIPE 2}, which contains the output of \tx{b}.

                This is effectively how the piping mechanism presented works. However, after the
                \tx{stdout} and \tx{stdin} of the current process are set to the pipes, the pipes are
                now no longer relevant to the process. As a result, they are now \bb{closed.}
                \clearpage

                After this, the command is then executed. Since the command could also be any
                of our internal commands, the command is then parsed through to check whether
                it is internal. If it is, then the prospective function is run as a result.
                If it isn't however, \tx{execve} is used to execute the external command.
                
                The parent block only waits until the status of the current child is gathered,
                at which point the \tx{\$EXITCODE} shell variable is set to it.

                Before exiting the loop, two things happen. The array of arguments, and the array
                of paths are both freed, as they were only useful for the execution of the current
                function, and the \tx{p} variable is incremented by 2, hence moving onto the next pipe.

                Once the loop exits, all the pipes are then closed, as the piping has stopped, and
                the \tx{wait} function is used in order to wait for any remaining processes that are
                still active.

    \chapter{Testing the \ii{eggshell}}





\end{document}